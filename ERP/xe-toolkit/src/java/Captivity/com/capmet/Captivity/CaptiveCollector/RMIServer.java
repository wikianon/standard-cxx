/****************************************************************************
**
** Copyright (c) 2006-2007 Captive Metrics Software Corporation.
**                    All rights reserved.
**
** This file is part of the CaptiveCollector application of Captivity.
**
** This file may be used under the terms of the GNU General Public
** License version 2.0 as published by the Free Software Foundation
** and appearing in the file LICENSE-GPL.txt contained within the
** same package as this file. This software is subject to a
** dual-licensing mechanism, the details of which are outlined in
** file LICENSE-DUAL.txt, also contained within this package. Be sure
** to use the correct license for your needs. To view the commercial
** license, read LICENSE-COMMERCIAL.txt also contained within this
** package.
**
** If you do not have access to these files or are unsure which license
** is appropriate for your use, please contact the sales department at
** sales@captivemetrics.com.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

package com.capmet.Captivity.CaptiveCollector;

import java.rmi.*;
import java.rmi.server.*;
import javax.rmi.ssl.*;
import java.io.File;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Set;
import java.util.Map;
import java.util.Hashtable;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Date;
import java.util.Locale;
import com.capmet.metrics.rmi.*;
import com.capmet.metrics.CmOSFlavor;

/**
 * RMIServer is the RMI Server class for Captive Metrics classes. This server
 * contains the remote methods for the <CODE>PerformanceHost,
 * PerformanceCategory</CODE> and <CODE>PerformanceField</CODE> classes.
 * <p>
 * @author Richard Pettit
 * @since JDK 1.5
 * @date December 2005
 * @version 1.0
 */
public final class RMIServer extends UnicastRemoteObject implements RMIMethods {
    /**
     * A mapping of <CODE>UID</CODE> to the <CODE>Object</CODE>
     * that it represents.
     */
    class ObjectMap extends Hashtable<UID, Object> {}

    /**
     * A mapping of <CODE>hashCode()</CODE> to the
     * <CODE>LocalField</CODE> that it represents.
     */
    class FieldCollection extends Hashtable<UID, LocalField> {}
    
    /* a Synchronized Object to put all of this data into */
    private class SynchronizedObject {
        /**
         * The <CODE>LocalHost</CODE> object with native method access to
         * the data needed by <CODE>PerformanceHost</CODE>.
         */
        public LocalHost mdrHost;
        /**
         * The map of hash codes to objects.
         */
        public ObjectMap objectMap;
        /**
         * The number of remote method calls to this server.
         */
        public long rmcCount = 0;
        /**
          * The version string of the collector.
          */
        public final String CaptiveCollectorVersion = "1.2 [April 2008]";
        /**
         * The start time of this server.
         */
        public Date startTime;
        /**
         * A unique identifier challenge generated by the constructor
         * and must be provided by a process wishing the collector to
         * shut down.
         */
        public UID challenge;
    }

    private SynchronizedObject SO = null;
    
    /**
     * Constructor for non-secure version of RMIServer.
     * @param top The top property indicating the installation
     * directory of the application.
     * @throws java.rmi.RemoteException RMI exception
     */
    public RMIServer(String top) throws RemoteException {
        common(top);
    }

    /**
     * Constructor for secure version of RMIServer.
     * @param top The top property indicating the installation
     * directory of the application.
     * @param csf The client side socket factory.
     * @param ssf The server side socket factory.
     * @throws java.rmi.RemoteException RMI exception
     */
    public RMIServer(String top,
        SslRMIClientSocketFactory csf, SslRMIServerSocketFactory ssf)
            throws RemoteException {
        super(REGISTRY_PORT, csf, ssf);
        common(top);
    }

    // defined in jmdr library - sad
    private native void chmod(String fileName, int mode);

    private synchronized void common(String top) throws RemoteException {
        SO = new SynchronizedObject();

        SO.startTime = new Date();
        SO.mdrHost = new LocalHost();
        SO.objectMap = new ObjectMap();
        SO.challenge = new UID();

        String hostName;

        try {
            hostName = InetAddress.getLocalHost().getHostName().split("\\.")[0];
        } catch(UnknownHostException e) {
            throw new RuntimeException(e.getMessage());
        }

        String cFile = top + File.separatorChar + "logs"
            + File.separatorChar + "CaptiveCollector" + File.separatorChar +
            "challenge" + '.' + hostName;

        try {
            File f = new File(cFile);
            if (f.exists())
                f.delete();
            FileOutputStream fos = new FileOutputStream(f);
            ObjectOutputStream oos = new ObjectOutputStream(fos);

            oos.writeObject(SO.challenge);
            oos.close();
            chmod(cFile, 0400);
        } catch(IOException e) {
            CaptiveCollector.log.severe(e.getMessage());
            throw new RemoteException(e.getMessage());
        }
    }
    
    /**
     * Get the OS platform designation as specified by the <code>CmOSFlavor</code> data type.
     * This is a <CODE>PerformanceHost</CODE> remote method.
     * @throws RemoteException RMI exception
     * @return The OS platform designation.
     * @see <CODE>com.capmet.metrics.CmOSFlavor</CODE>
     */
    public CmOSFlavor getOSFlavor() throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            return SO.mdrHost.getOSFlavor();
        }
    }
    
    /**
     * Get the names of the categories available on this platform.
     * This is a <CODE>PerformanceHost</CODE> remote method.
     * @throws RemoteException RMI exception
     * @return An array of <CODE>String</CODE> containing the names of the performance categories available.
     */
    public String[] getCategoryNames() throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                return SO.mdrHost.getCategoryNames();
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Return the instance names of an n-tuple category.
     * This is a <CODE>PerformanceCategory</CODE> remote method.
     * @param objectId The lookup key for the remote object.
     * @throws RemoteException RMI exception
     * @return An array of <CODE>String</CODE> containing the instance names with the category.
     */
    public String[] getInstanceNames(UID objectId) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                CategorySource cat =
                        (CategorySource) SO.objectMap.get(objectId);
            
                return cat.getInstanceNames();
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Retrive the class properties for the <CODE>PerformanceCategory</CODE> class given the category name.
     * This is called from the constructor of the <CODE>PerformanceCategory</CODE> class.
     * @param category The name of the category whose properties are retrieved.
     * @throws RemoteException RMI exception
     * @return A PerformanceCategoryInfo structure containing the properties.
     * @see <CODE>com.capmet.metrics.rmi.PerformanceCategoryInfo</CODE>
     */
    public PerformanceCategoryInfo getPerformanceCategoryInfo(String category) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                CategorySource cat = new LocalCategory(category);
                PerformanceCategoryInfo pci = new PerformanceCategoryInfo();
            
                pci.categoryName = category;
                pci.categoryExplanation = cat.getCategoryExplanation();
                pci.categorySupported = cat.isCategorySupported();
                pci.singleton = cat.isSingleton();
                pci.fieldCount = cat.getFieldCount();
                pci.objectId = new UID();
            
                SO.objectMap.put(pci.objectId, cat);
            
                return pci;
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Refresh the entire performance category at once.
     * This is a <CODE>PerformanceCategory</CODE> remote method.
     * @param objectId The hash code of the <CODE>PerformanceCategory</CODE> object.
     * @throws RemoteException RMI exception
     */
    public void categoryRefresh(UID objectId) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                CategorySource cat =
                        (CategorySource) SO.objectMap.get(objectId);
            
                cat.categoryRefresh();
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Refresh the entire performance category and
     * compute the differences from the previous refresh.
     * This is a <CODE>PerformanceCategory</CODE> remote method.
     * @param objectId The hash code of the <CODE>PerformanceCategory</CODE> object.
     * @throws RemoteException RMI exception
     */
    public void categoryRefreshRates(UID objectId) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                CategorySource cat =
                        (CategorySource) SO.objectMap.get(objectId);
            
                cat.categoryRefreshRates();
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Return boolean indication of whether the field in question is supported.
     * This is a <CODE>PerformanceCategory</CODE> remote method.
     * @param objectId The hash code of the <CODE>PerformanceCategory</CODE> object.
     * @param fieldNumber The integer field number.
     * @throws RemoteException RMI exception
     * @return <CODE>true</CODE>: the field is supported - <CODE>false</CODE>: the field is not supported
     */
    public boolean isFieldSupported(UID objectId, int fieldNumber) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                CategorySource cat =
                        (CategorySource) SO.objectMap.get(objectId);
            
                return cat.isFieldSupported(fieldNumber);
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Return the field name given the field number.
     * This is a <CODE>PerformanceCategory</CODE> remote method.
     * @param objectId The hash code of the <CODE>PerformanceCategory</CODE> object.
     * @param fieldNumber The integer field number.
     * @throws RemoteException RMI exception
     * @return The <CODE>String</CODE> name of the field.
     */
    public String getFieldName(UID objectId, int fieldNumber) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                CategorySource cat =
                        (CategorySource) SO.objectMap.get(objectId);
            
                return cat.getFieldName(fieldNumber);
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Return the field explanation given the field number.
     * This is a <CODE>PerformanceCategory</CODE> remote method.
     * @param objectId The hash code of the <CODE>PerformanceCategory</CODE> object.
     * @param fieldNumber The integer field number.
     * @throws RemoteException RMI exception
     * @return The <CODE>String</CODE> explanation for the field.
     */
    public String getFieldExplanation(UID objectId, int fieldNumber) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                CategorySource cat =
                        (CategorySource) SO.objectMap.get(objectId);
            
                return cat.getFieldExplanation(fieldNumber);
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Return the field number given the field name.
     * This is a <CODE>PerformanceCategory</CODE> remote method.
     * @param objectId The hash code of the <CODE>PerformanceCategory</CODE> object.
     * @param fieldName The <CODE>String</CODE> field name.
     * @throws RemoteException RMI exception
     * @return The integer field number.
     */
    public int getFieldNumber(UID objectId, String fieldName) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            CategorySource cat =
                    (CategorySource) SO.objectMap.get(objectId);
        
            try {
                return cat.getFieldNumber(fieldName);
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Return a <CODE>String</CODE> array containing the names of all the fields.
     * This is a <CODE>PerformanceCategory</CODE> remote method.
     * @param objectId The hash code of the <CODE>PerformanceCategory</CODE> object.
     * @throws RemoteException RMI exception
     * @return The <CODE>String</CODE> names of all of the fields in the category.
     */
    public String[] getAllFieldNames(UID objectId) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                CategorySource cat =
                        (CategorySource) SO.objectMap.get(objectId);
            
                return cat.getAllFieldNames();
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Return a <CODE>String</CODE> array containing the names of the supported fields.
     * This is a <CODE>PerformanceCategory</CODE> remote method.
     * @param objectId The hash code of the <CODE>PerformanceCategory</CODE> object.
     * @throws RemoteException RMI exception
     * @return The <CODE>String</CODE> names of the supported fields in the category.
     */
    public String[] getSupportedFieldNames(UID objectId) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                CategorySource cat =
                        (CategorySource) SO.objectMap.get(objectId);
            
                return cat.getSupportedFieldNames();
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Retrive the class properties for the <CODE>PerformanceField</CODE> class given the category name,
     * field name and instance name.
     * This is called from the constructor of the <CODE>PerformanceField</CODE> class.
     * @param category The performance category name.
     * @param field The performance field name.
     * @param instance The instance name.
     * @throws RemoteException RMI exception
     * @return A <CODE>PerformanceFieldInfo</CODE> class containing the properties.
     * @see <CODE>com.capmet.metrics.rmi.PerformanceFieldInfo</CODE>
     */
    public PerformanceFieldInfo getPerformanceFieldInfo(
            String category, String field, String instance) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                LocalField pc =
                        new LocalField(category, field, instance);
                PerformanceFieldInfo pfi = new PerformanceFieldInfo();
            
                pfi.supported = pc.isSupported();
                pfi.objectId = new UID();
            
                SO.objectMap.put(pfi.objectId, pc);
            
                return pfi;
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Get the current value of the <CODE>PerformanceField</CODE> referenced by the hash code.
     * @param objectId The hash code of the <CODE>PerformanceField</CODE> object.
     * @throws RemoteException RMI exception
     * @return An <CODE>Object</CODE> which will be either an <CODE>Integer, Long, Double, String</CODE> or <CODE>Boolean</CODE>.
     */
    public Object getValue(UID objectId) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                LocalField pc =
                        (LocalField) SO.objectMap.get(objectId);
            
                return pc.getValue();
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Get the next value of the <CODE>PerformanceField</CODE> referenced by the hash code.
     * @param objectId The hash code of the <CODE>PerformanceField</CODE> object.
     * @throws RemoteException RMI exception
     * @return An <CODE>Object</CODE> which will be either an <CODE>Integer, Long, Double, String</CODE> or <CODE>Boolean</CODE>.
     */
    public Object getNextValue(UID objectId) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                LocalField pc_obj =
                        (LocalField) SO.objectMap.get(objectId);
            
                return pc_obj.getNextValue();
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Release <CODE>PerformanceField</CODE> object memory associated with the hash code.
     * @param objectId The hash code of the <CODE>PerformanceField</CODE> object.
     * @throws RemoteException RMI exception
     */
    public void deleteObject(UID objectId) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            SO.objectMap.remove(objectId);
        }
    }
    
    /**
     * Retrieve a hash code for a new server-side FieldCollection.
     * @return The hash code of the <CODE>FieldCollection</CODE> object.
     * @throws RemoteException RMI exception
     */
    public UID getCCInstance() throws RemoteException {
        synchronized(SO) {
            FieldCollection mc = new FieldCollection();
            UID objectId = new UID();
        
            SO.rmcCount++;
            SO.objectMap.put(objectId, mc);
            return objectId;
        }
    }
    
    private FieldArray makeFieldArray(FieldCollection mc) throws RemoteException {
        try {
            // allocate new array for return
            FieldArray fieldArray = new FieldArray(mc.size());
            
            // foreach node in mc
            for(Map.Entry<UID, LocalField> e : mc.entrySet()) {
                // the key is the CollectionItem object id
                UID ciObjectId = e.getKey();
                
                // the value is the mdr data structure
                LocalField fieldObj = e.getValue();
                
                // allocate a new pair
                FieldCollectionPair cp = new FieldCollectionPair();
                
                // populate it
                cp.ciObjectId = ciObjectId;
                cp.value = null;
                if (fieldObj.isSupported())
                    cp.value = fieldObj.getValue();
                
                // store it
                fieldArray.addElement(cp);
            }
            
            return fieldArray;
        } catch(Exception e) {
            throw new RemoteException(e.getMessage());
        }
    }
    
    /**
     * Query the collection of counters specified by <CODE>coll</CODE>.
     * @param objectId The hash code of the server-side <CODE>FieldCollection</CODE> object.
     * @param coll The collection of counters to be queried.
     * @return The <CODE>coll</CODE> parameter populated with new data.
     * @throws RemoteException RMI exception
     */
    public FieldArray processCollection(UID objectId, CounterCollection coll) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                // get the FieldCollection from objectMap
                FieldCollection mc = (FieldCollection) SO.objectMap.get(objectId);
            
                // foreach node in the collection
                for(Map.Entry<UID, CollectionItem> e : coll.entrySet()) {
                    // the key is the object id of the CollectionItem
                    UID ciObjectId = e.getKey();
                
                    // the value is the CollectionItem itself
                    CollectionItem ci = e.getValue();
                
                    // allocate a new field data structure
                    LocalField fieldObj = new LocalField(
                            ci.category, ci.field, ci.instance);
                
                    // put it in the collection
                    mc.put(ciObjectId, fieldObj);
                }
            
                return makeFieldArray(mc);
            } catch(Exception e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Add a new collection item to an existing collection.
     * @param objectId The unique id of the collection.
     * @param ci The new collection item.
     * @throws RemoteException RMI exception
     */
    public void putCollectionItem(UID objectId, CollectionItem ci) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                // get the FieldCollection from objectMap
                FieldCollection mc = (FieldCollection) SO.objectMap.get(objectId);
            
                // build a new field
                LocalField fieldObj = new LocalField(
                        ci.category, ci.field, ci.instance);
            
                // add
                mc.put(ci.objectId, fieldObj);
            } catch(Exception e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Remove a collection item from an existing collection.
     * @param objectId The unique id of the collection.
     * @param ciObjectId The unique id of the collection item.
     * @throws RemoteException RMI exception
     */
    public void removeCollectionItem(UID objectId, UID ciObjectId) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                // get the FieldCollection from objectMap
                FieldCollection mc = (FieldCollection) SO.objectMap.get(objectId);
            
                // remove
                mc.remove(ciObjectId);
            } catch(Exception e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Query all of the counters in the collection.
     * @param objectId The unique id of the collection.
     * @throws RemoteException RMI exception
     * @return A <CODE>FieldArray</CODE> object with the updated counters.
     */
    public FieldArray queryCollection(UID objectId) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                // get the FieldCollection from objectMap
                FieldCollection mc = (FieldCollection) SO.objectMap.get(objectId);
            
                return makeFieldArray(mc);
            } catch(Exception e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    // Direct access methods.
    
    /**
     * Constructor for the direct access process class.
     * @throws RemoteException RMI exception
     * @return The unique id of the server-side object.
     */
    public UID PCons() throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                ProcSlob ps = new ProcSlob();
                UID uid = new UID();
            
                SO.objectMap.put(uid, ps);
            
                return uid;
            } catch(Exception e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Update the <CODE>ProcSlob</CODE> structure and return
     * the updated processes.
     * @param objectId The unique id of the <CODE>ProcSlob</CODE>
     * @throws RemoteException RMI exception
     * @return A <CODE>D.PT</CODE> object.
     */
    public D.PT Pget(UID objectId) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                ProcSlob ps = (ProcSlob) SO.objectMap.get(objectId);
                D.PT dt = new D.PT();
            
                // get a new rates sample
                ps.refreshRates();
            
                // pick the fruit
                for(Map.Entry<String, D.PN> e : ps.entrySet())
                    dt.put(e.getKey(), e.getValue());
            
                // copy support bits
                dt.supportFlags = ps.supportFlags;
            
                return dt;
            } catch(Exception e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    // Pause a second and exit.
    private class Seppuku extends Thread {
        public void run() {
            try { Thread.sleep(1000); } catch(Exception e) {}
            System.exit(0);
        }
    }

    /**
     * Shut down the server.
     * @throws RemoteException RMI exception
     */
    public boolean CCShutdown(UID challenge) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            if (!challenge.equals(SO.challenge))
                return false;
            String msg = "CaptiveCollector shutting down.";
                // not my bug: catalog lookup hangs
                // String msg = CaptiveCollector.msgs.getString("Shuting_Down");
            CaptiveCollector.log.info(msg);
            Seppuku tanto = new Seppuku();
            tanto.start();
            return true;
        }
    }
    
    /**
     * Get the localized version of the en_US string.
     * @param enUsName The en_US string.
     * @throws RemoteException RMI exception
     * @return The localized version of the string if available.
     */
    public String getLocalizedName(String enUsName) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                return SO.mdrHost.getLocalizedName(enUsName);
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Get the en_US version of the localized string.
     * @param localizedName The localized string.
     * @throws RemoteException RMI exception
     * @return The en_US version of the string if available.
     */
    public String getEnUsName(String localizedName) throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            try {
                return SO.mdrHost.getEnUsName(localizedName);
            } catch(PerformanceException e) {
                throw new RemoteException(e.getMessage());
            }
        }
    }
    
    /**
     * Retrieve the locale of the server host.
     * @throws RemoteException RMI exception
     * @return The <CODE>Locale</CODE> structure.
     */
    public Locale getLocale() throws RemoteException {
        synchronized(SO) {
            SO.rmcCount++;
            return Locale.getDefault();
        }
    }
    
    /**
     * Retrieve the status of the server.
     * @throws RemoteException RMI exception
     * @return A <CODE>CaptiveCollectorStats</CODE> structure with stats.
     */
    public CaptiveCollectorStats CCStatus() throws RemoteException {
        synchronized(SO) {
            CaptiveCollectorStats cs = new CaptiveCollectorStats();
            Runtime rt = Runtime.getRuntime();

            SO.rmcCount++;
            cs.version = SO.CaptiveCollectorVersion;
            cs.startTime = SO.startTime;
            cs.currentTime = new Date();
            cs.rmcCount = SO.rmcCount;
            cs.objectsInCache = SO.objectMap.size();
            cs.jvmProcessors = rt.availableProcessors();
            cs.jvmTotalMemory = rt.totalMemory();
            cs.jvmFreeMemory = rt.freeMemory();

            return cs;
        }
    }

    /**
     * If this function returns then the connection is valid.
     * @return true - valid connection; false - connection is broken
     */
    public boolean hasValidConnection() {
        return true;
    }
}
